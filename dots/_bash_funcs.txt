#!/bin/bash
###############################################################################
#
# Name: .bashrc.funcs
# Author: Travis Goldie
# Date: January 2015
# Purpose: Functions for the bash terminal
#
###############################################################################
#-------------------------------------------------------------
# Functions
#-------------------------------------------------------------
# Get list of missing keys for apt-get. Then make cmds to update keys
aptkeys()
{
    sudo echo "Getting list of keys..."
    keyList=$( (  sudo apt-get update  2>&1 >/dev/null ) | grep "NO_PUBKEY" | sed 's/.*NOPUBKEY //' )

    # Get the list of the key values
    for key in $keyList; do echo "$key" ; done

    # Now make commands to add to a script...
    for key in $keyList ; do
        echo "apt-key adv --keyserver keyserver.ubuntu.com --recv-keys $key"
    done

    echo

    for key in $keyList ; do
        echo "gpg --keyserver subkeys.pgp.net --recv $key && gpg --export --armor $key | apt-key add -"
    done
}

#Tests if string ($1) contains the substring ($2)
contains ()
{
    [[ $# < 2 ]] && echo "Usage: contains \$string \$substring" >&2
    string=$1 ; substring=$2
    if test "${string#*$substring}" != "$string" ; then
        return 0    # $substring is in $string
    else
        return 1    # $substring is not in $string
    fi
}

#Case insensitive test if string ($1) contains the substring ($2)
icontains ()
{
    str=$( echo $1 | tr '[:upper:]' '[:lower:]' )
    substr=$( echo $2 | tr '[:upper:]' '[:lower:]' )
    return $( contains $str $substr )
}

#Convert files to mp3 using VLC. Uses same base name
convertmp3 ()
{
	USAGE="$0 inDir outDir" ;  indir="$1/*"
	#Get the settings
	acodec="acodec=mp4a" ; arate="ab=192" ; bitrate="vb=1024"
	channels="channels=6" ; mux="mux=ts" ; outFmt="mp3"
	vcodec="vcodec=h264" ; vlc="/usr/bin/vlc"

	for path in $indir ; do
  		dst="dst=\"${2}$( basename ${path%.*} ).${outFmt}\""
		transcode="#transcode{$vcodec,$bitrate,$acodec,$arate,$channels}:standard{$mux,$dst,access=file}"
		$vlc -I dummy -vv "$path" --sout "$transcode" vlc://quit
	done
}

# Replace resolv.conf file with SIOS's version
cpresolv ()
{
	sharedAll=$DROPBOX/shared/all
	if [[ $1 == -r ]]; then
		echo "Using home resolv.conf"
		sudo cp $sharedAll/etc/resolv.conf.home /etc/resolv.conf
		return $?
    else
        echo "Using SIOS resolv.conf"
        sudo cp $sharedAll/etc/resolv.conf.sios /etc/resolv.conf
		return $?
	fi
}

# Checks for conflict files in Dropbox
dbconflict () {
    dump="$HOME/tmp/dbdump"
    tmp=$( mktemp )
    mkdir -p "$dump"
    find $DROPBOX -iname "*\ \(* conflicted\ *" -o -iname "*\(Case Conflict*" -o -iname "*\(Selective Sync Conflict\)*" > $tmp

    while read val ; do
        valNew=$(echo $val | sed  's/\//-/g')
        echo "Moving $val to $dump"
        mv "$val" "$dump/$valNew"
    done < $tmp
}

# Debug wrapper for bash functions
dbg ()
{
	set -xv ; eval $@ ; set +xv
}

# Disable <C-s> before running cmd and re-enable it afterward
disable_ctrl_s()
{
    local STTYOPTS="$(stty --save)"
    stty stop '' -ixoff
    command "$@"
    stty "$STTYOPTS"
}

#Gets the IP addresses of any interface
getip ()
{
   if [[ $# -eq 0 ]]; then
      inf="eth0"
   elif [[ $# -gt 1 || "$1" == "-h" ]]; then
      echo "USAGE: Returns the IP address of the interface
          \$1 - Number of the interface (for example: 0 for eth0) "
      return 1
   elif [[ $1 =~ ^[0-9]$ ]]; then
      inf="eth$1"
   else
      inf=$1
   fi

   unalias grep
   ifconfig $inf | grep 'inet addr:' | cut -d: -f2 | awk '{ print $1}'
}


#Backup gpg keys to stoarge
gpgbackup()
{
    unset prefix sshkeys
    prefix='beeryard' ;  sshkeys=$HOME/.sshkeys ; uid='Travis Goldie'
    pushd $sshkeys

    #Now do all the backing up
    gpg --export $uid > ${prefix}.pub.gpg
    gpg --export --armor $uid > ${prefix}.pub.asc
    gpg --export-secret-keys $uid > ${prefix}.gpg
    gpg --export-secret-keys --armor $uid > ${prefix}.asc
    gpg --finger > ${prefix}.finger.txt #fingerprint
    gpg --output ${prefix}.revoke.asc --gen-revoke $uid
    popd
}

#Store password to a variable. Does not echo text like a normal pwd prompt
getpwd()
{
    #TODO WIP
    unset out stty_orig
    [[ -z $1 ]] && out=$1 || out="Password: "
	stty_orig=$( stty -g ) ; stty -echo ; read -p "$out" pass ; stty $stty_orig
    echo "$pass"
}


#Makes reading markdown file easier
_mdown ()
{
    if [[ $1 == "-b" ]] ; then
        in=$2 ; out="html" ; reader="lynx -stdin"
    elif [[ $1 == "-m" ]] ; then
        in=$2 ; out="man" ; reader="man -l -"
    else
        in=$1 ; out="man" ; reader="man -l -"
    fi
    cmd="pandoc -s -f markdown -t $out $in | $reader"
    echo $cmd ; eval $cmd
}

mdown()
{
    USAGE="Usage: Reads Markdown readme's. \n
            \$1 - File to read \n
            -b  - Use browser\n
            -h  - Show this message and return\n
            -m  - Read using man pages (default)"
    if [[ -z $1 || $1 == "-h" ]] ; then
        echo -e $USAGE && return
    fi
    _mdown $@
}

#Mount steeleye resources
mountst ()
{
	unset ops_1 mountpt pass stty_orig
	sudo echo -n #go ahead and get sudo cert
	#get password. use stty to not show password on screen
	stty_orig=$( stty -g ) ; stty -echo ; read -p "AD Password: " pass ; stty $stty_orig

	ops_1="nounix,user,uid=1000,gid=1000,username=$USER,password=$pass"

    # smbfs has been replaced with cifs
	cmd="sudo mount -o $ops_1 -t cifs"

	mountpt=/mnt/steel
    if ! mountpoint -q $mountpt ; then
        sudo mkdir -p $mountpt
        $cmd //hancock.sc.steeleye.com/steel/ $mountpt
    fi

    mountpt=/mnt/$USER
    if ! mountpoint -q $mountpt ; then
        sudo mkdir -p $mountpt
        $cmd //hancock.sc.steeleye.com/steel/steeleye/$USER $mountpt
    fi

	echo "" #add a new line for the fun of it
}

#Send gnome notification when command completes
notify()
{
	[[ $# == 0 ]] && _notifysend -h && return 2
	_notifysend ${@}
}

#Send gnome notification only when command errors
notifyerror()
{
	[[ $# == 0 ]] && _notifysend -h && return 2
	_notifysend -n ${@}
}

#Generic wrapper for notify accounts.
_notifysend()
{
	unset cmd cmdname flag msg ret
	#If first arg is "-h" send out usage and exit
	[[ $1 == "-h" ]] && echo "Usage: notifysend command [args]" && return
	[[ $1 == "-n" ]] && flag=1 && shift

	#Executes the command, checks its return code sends notify message
	cmd=${@} ; eval ${cmd} ; ret=$? ; cmdname=$( echo -n ${cmd[0]} )

	#If flag is set and 0 return code, then just exit
	[[ $ret == 0 ]] && [[ $flag == 1 ]] && return 0

	if [ $ret == 0 ]; then
		msg="Command completed successfully."
	else
		msg="Command failed with return code of $ret"
	fi

	notify-send --hint=int:transient:100 -u normal -t 100  "${cmd[@]}" "${msg}"
}

#Change the name of tabs in xterm
renametab()
{
	#\033 is escape char and \007 is BEL char
	echo -ne "\033]0;${1}\077" ;
}

#Use rdp to access Win machines
_rdpst()
{
    unset d dom geo K pass user resources val;
	d=".sc.steeleye.com"
    geo="-g 1152x864" #geo="-f"
    pass="-p frs.123"
    user="-u Administrator"
	resources="-r clipboard:CLIPBOARD"

	for arg in $@ ; do
		case $arg in
        "-d" ) dom="-d qagroup.com" && shift ;;
        "-D" ) dom="-d $2" && shift 2 ;;
        "-f" ) geo="-f" && shift ;;
        "-g" ) geo="-g 1152x864" && shift ;;
        #"-g" ) geo="-g 85%" && shift ;;
        "-G" )
            #If $2 does not end in '%' then append it. Otherwise use that value.
            #-i: ignore case, -q: quite, -v: invert-match, -E: extend regex
            if $( echo "$2" | egrep -iq "*x*" ) ; then
                val=${2}
            elif $( echo "$2" | egrep -iqv "%$") ; then
                val="${2}%"
            else
                val="$2"
            fi
            geo="-g $val" && shift 2 ;;
        "-K" ) K="-K" && shift ;;
        "-p" ) pass="-p $2" && shift 2 ;;
        "-P" ) resources+=" -r printer:Canon-iR-ADV-C2225" ;; #FIXME
        "-t" ) dom="-d qatest.com" && pass="-p lk" && shift ;;
        "-U" ) user="-u QAGROUP\\Administrator" && shift ;;
		esac
	done

	#Hack way to get last arg. Loops through args and leaves last one in "lastarg"
	for lastarg; do true ; done

	#Acts as a "if in list" consturct.
	if [[ ${SIOSWIN[@]} =~ $lastarg ]] ; then
		user="-u $USER" ; host=${lastarg}
		[[ $lastarg == "vclient" ]] && unset dom
		[[ $lastarg == "saluda" ]] && host=${host}${d} && dom="-d steeleye" && unset pass

	elif [[ "$lastarg" =~ ^[0-9]+ ]] ; then
		host="cae-qa-v${lastarg}${d}"

	else
		host="${lastarg}${d}"
	fi

	#Build command, echo it to STDOUT, and then use 'eval'
	cmd="rdesktop $resources -T '$host $K' $K $dom $geo $user $pass $host"
	echo "Running command: $cmd" ; eval $cmd
}

rdpst ()
{
	unset USAGE

    USAGE="USAGE: $FUNCNAME [-K] [-U] [-f | -g | -G percent] [-d | -t | -D domain] [-p pass] hostname \n
    \t Default domain: sc.steeleye.com \n
    \t Default resolution is 1152x864"

   [[ $# == 0 ]] && echo -e $USAGE  && return 1
	teelog _rdpst $@ & disown
}

#Use scp to send files to system
scpst ()
{
	#Build hostname
   [[ $# < 1 ]] && echo "Usage: scpst files \"hostname\"" && return 1
   unset val ; unset user ; val="$1" ; d=".sc.steeleye.com"
   [[ "$val" =~ ^[0-9]+$ ]] && host="cae-qa-v${val}${d}" || host="${val}${d}"

   for i in buildrhel4 fenric hancock ingress ; do
      [[ $i == $val ]] &&  user="tgoldie" && break
   done

   #If more then one arg, shift off 1st arg, then set in an array
   [[ $# > 1 ]] && shift && declare -a files=($@)

   #If $user is blank/unset, set $user to "root".
	#Then exectute command remotely.
   user=${user:-"root"} ; scp ${files[@]} ${user}@${host}
}

#Copy files to windows virtual machine
scpw ()
{
	unset d && [[ $1 == "-d" ]] && d=$2 && shift 2
	# if -d param given, use that dir. Otherwise use default
	d=${d:-"c:\\tmp"}

	echo "Destination dir: $d"
   scp -r -i $WINKEY $@ $USER@vclient:${d}
}

#SSH into home network using DNS.
sshb ()
{
	#$1 - port to forward to
	unset cmd d port user ; port=2102 ; user=$USER

   #If more then one arg, shift off 1st arg, then set in an array
   [[ $# > 1 ]] && shift && declare -a cmd=($@)

	opts="-X -vv -p ${port} -i ${HOME}/.ssh/beeryard_key"
	ssh $opts ${user}@${HOMEDNS} ${cmd[@]}
}

#Sets up remote port to NomThoseApples Bypasses firewall.
sshn ()
{
	#If "-c", create the port using either default port or specified port
	usage="Usage: sshn [-c] [hostport] \nhostport: port used locally"
	[[ $1 == "-c" ]] && shift && c="1"

	#Either first arg is null or a number. Otherwise display usage and exit
	( [[ -z "$1" ]] ||  [[ $1 =~ [0-9]+ ]]  ) || ( echo $usage && return )

	ops="-X -p 8120 -N -f"
	d="nomthoseapples.servebeer.com"
	user="root" ; h=${1:-"8120"}

	#Ran on the remote phone
	[[ -n "$c" ]] && ssh ${ops} -R ${h}:localhost:8120 ${user}@${d}

	#Run this on the remote machine
	[[ -z "$c" ]] && ssh -p $h ${user}@localhost
}

#Sets up remote port to beeryardnet. Bypasses firewall.
_sshr ()
{
	#If "-c", create the port using either default port or specified port
	unset d h p ops user
	[[ $1 == "-c" ]] && shift && c="1"

	#$p is usually 2102
	p=$1 ; ops="-p $p -XNfvvv " ; d=$HOMEDNS ; user="tgoldie" ; h=8080

	#Do this to create the remote port on the current host machine
	echo "cmd: ssh ${ops} -R ${h}:localhost:22 ${user}@${d}"
	[[ -n "$c" ]] && ssh ${ops} -R ${h}:localhost:22 ${user}@${d}

	#Do this on the local machine. Connects to the remote machine
	[[ -z "$c" ]] && ssh -p $h ${user}@localhost
}

sshr()
{
	unset usage ; usage="Usage: sshr [-c] [hostport]"

	#Hack way to get last arg. loops through args and leaves last one in "lastarg"
	for lastarg; do true ; done

	( [[ "$1" == "-c" ]] && ! [[ $lastarg =~ [0-9]+ ]] ) || ( echo $usage && return 1 )

	[[ $1 == "-c" ]] 	&& _sshr -c $2 1>/tmp/sshr.log 2>&1
		return 2

	_sshr 2>/tmp/sshr.log
		return 0
}

#SSH into steeleye systems
_sshst()
{
    #Build hostname
    unset cmd d host user val ;
    val="$1" ; d=".sc.steeleye.com" ; user="root" ; host="${val}${d}"

    if [[ "$val" =~ ^[0-9]+$ ]] ; then
        # These are for the QA machines
        host="cae-qa-v${val}${d}"

    elif [[ "$val" =~ ^ng-v[0-9]+$ ]] ; then
        # These are for next gen machines
        user="root"

    elif [[ "$val" =~ ^v[0-9]+$ ]] ; then
        # These are for next gen machines
        user="root" ; host="ng-${val}${d}"

    elif [[ ${SIOSLIN[@]} =~ $val ]] ; then
        # These are for the internal (build) boxes
        user="tgoldie" ; host="${val}${d}"

    elif [[ ${SIOSDSK[@]} =~ $val ]] ; then
        # These are machines outside the lab. Not part of "sc" domain
        user="tgoldie" ; host="${val}.steeleye.com"
    fi

    #If more then one arg, shift off 1st arg, then set in an array
    [[ $# > 1 ]] && shift && declare -a cmd=( $@ )

    #Then exectute command remotely.
    echo "Connecting  ${host} as user ${user}" >&2
    ssh -X ${user}@${host} ${cmd[@]}
}

sshst() {
   [[ $# == 0 ]] && echo "Usage: sshst host [commands]" && return 1
	_sshst ${@}
	#teelog _sshst ${@}
}

#SSH into vclient windows machine
sshw()
{
   ssh -i $WINKEY $USER@vclient $@ ;
}


#Either logs to a tmp file or uses tee to log and send to STDOUT
teelog()
{
	unset err errfd erronly filename log;
	erronly=false

	if [[ $# == 0 ]];then
		echo "USAGE: $FUNCNAME [-e] [-t] cmd"
		return 1
	fi

	if [[ $1 == "-e" ]]; then
		erronly=true
		shift
	fi

	if [[ $1 == "-t" ]]; then
		ltee=true
		shift
	else
		ltee=$TEE
	fi

	# Take basename and then strip off the leading underscore if there is one
	# If there isn't one, then nothing happens
	filename=$( basename $1 | sed "s/^_//" )

	cmd=${@}
	err="/tmp/${filename}.err"
	log="/tmp/${filename}.log"

	if [[ $ltee == true && $erronly == false ]] ; then
		eval $cmd >( tee $log ) 2>( tee $err >&2 )
	elif [[ $ltee == true && $erronly == true ]] ; then
		eval $cmd 2> >( tee $err >&2 )
	elif [[ $ltee == false && $erronly == true ]]; then
		#echo "no TEE and erronly"
		eval $cmd 2> $err
	else
		#echo "no tee and no errornly"
		eval $cmd >$log 2>$err
	fi
}

#Open Teamviewer from a remote connection
tv()
{
	export DISPLAY=:0;
	if  ! ps ax | grep -v "grep" | grep teamviewer >/dev/null ; then
		/usr/bin/teamviewer
	fi
	gnome-screensaver; gnome-screensaver-command -d
}

# Allows vim to use <C-S> mapping
vim()
{
    disable_ctrl_s vim -p "$@"
}

# Easy shorthand for editing remote files using vim
# XXX Duplicates the vim method above, since it uses the default vim command
vimscp()
{
    srv=$1 ; path=$2
    if ! contains $srv '@' ; then
        srv="root@${srv}"
    fi
    cmd="vim -p scp://${srv}/${path}"
    echo $cmd
    disable_ctrl_s $cmd
}

#Easier signon to WPA wireless
wpa ()
{
   [[ $# == 0 ]] && echo "Usage: wpa ESSID PASSWORD" && return 1

	essid=$1
	passwd=$2
	tmpcfg=$( mktemp )

	wpa_passphrase $essid $passwd > $tmpcfg
	if [[ $? != 0 ]]; then
		echo "Error with wpa_passphrase."
		exit 1
	fi
	wpa_supplicant -B -Dwext -i "wlan0" -c $tmpcfg
	if [[ $? != 0 ]]; then
		echo "Error with wpa_supplicant."
		exit 1
	fi

	rm $tmpcfg

	echo "You should now be connected to wireless AP ${essid}!"
}
