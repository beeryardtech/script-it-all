"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"
" Name: .vimrc (see _vimrc for gVim)
" Author: Travis Goldie
" Date: January 2012
" Purpose: Config file for vim
"
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Basics {
" Set the mapleader key. Default is '\'
"let mapleader = ','

set number
set background=dark
syntax on
set completeopt=longest,menuone
set autoread

" Set tabs and spaces handling
"set cindent
set tabstop=4
set shiftwidth=4
set expandtab

" set ignorecase smartcase, case-insensitive searching 
set ignorecase
filetype plugin indent on

" Fix to get Alt key shortcut to work. Maps Escape chars
" to their Alt combinations. For uppercase letters do the 
" same except use 'Z'.
let myChar='a'
while myChar <= 'z'
  exec "set <A-".myChar.">=\e".myChar
  exec "imap \e".myChar." <A-".myChar.">"
  let myChar = nr2char(1+char2nr(myChar))
endw

" Timeout is to tell difference between Meta encoding and hitting 2 keys
set timeout ttimeoutlen=50

" Makes backspace work more natually
"set backspace=2
set backspace=indent,eol,start


" Creates ctags for the current file
execute "set tags=./TAGS;/;" . $VIMBACKUP . "TAGS"


" Default keybinding is Ctrl-^
" Insert and command-line mode Caps Lock.
" Lock search keymap to be the same as insert mode.
set imsearch=-1

" Load the keymap that acts like capslock.
set keymap=insert-only_capslock
"
" Turn it off by default.
set iminsert=0

" }

" Diffs {
verbose map <C-Up> [c
verbose map <C-Down> ]c

" }

" Files {
set backup

" share windows clipboard
silent! set clipboard=unnamedplus 

" support both, in this order
set fileformats=unix,dos 


" Gets full path to file by default
verbose noremap <leader>g 1 <C-g>

" }

" Folding {
set foldenable " Turn on folding
set foldmarker={,} " Fold C style code (only use this as default 
                   " if you use a high foldlevel)
"set foldmethod=marker " Fold on the marker
"set foldmethod=indent
set foldlevel=100 " Don't autofold anything (but I can still 
                  " fold manually)
" what movements open folds
set foldopen=block,hor,mark,percent,quickfix,tag 
 
function SimpleFoldText()
    return getline(v:foldstart).' '
endfunction

" Custom fold text function (cleaner than default)
"set foldtext=SimpleFoldText()

" }

" Function (Code) Completing {
" Enables omnicomplete (a la IntelliSense)
set omnifunc=syntaxcomplete#Complete

" Maps the standard C-x to something easier
inoremap <C-]> <C-x>

" Youcompleteme (ycm) - enabled as a bundle
"let g:ycm_key_list_select_completion=['<TAB>', '<Down>', '<Enter>']
let g:ycm_key_list_select_completion=['<TAB>', '<Down>']
let g:ycm_autoclose_preview_window_after_completion=1

" Ultisnips
let g:UltiSnipsExpandTrigger="<c-tab>"
let g:UltiSnipsListSnippets="<c-s-tab>"

" }

" Movement {
" Move by row rather than line. Useful for wrapped lines.
nnoremap j gj
nnoremap k gk

" <space> now works like a browser
"nnoremap <space> <C-d>
nnoremap <Space> <PageDown>
noremap <C-space> <PageUp>

" Move by line rather than by row
"nnoremap gj j
"nnoremap gk k
"
" Can move around in insert mode
inoremap <C-h> <left>
inoremap <C-j> <down>
inoremap <C-h> <up>
"inoremap <C-h> <right>

" Move around windows
map <c-j> <c-w>j
map <c-k> <c-w>k
map <c-l> <c-w>l
map <c-h> <c-w>h

" }

" Pathogen load {
filetype off

" To disable a plugin, add it's bundle name to the following list
let g:pathogen_disabled = []

silent! call pathogen#infect()
silent! call pathogen#helptags()

filetype plugin indent on
syntax on

" }

" Extra Plugins Functionality {
map <leader>td <Plug>TaskList
map <leader>g :GundoToggle<CR>

" Rope commands - refactoring stuff
let ropevim_enable_shortcuts=1

noremap <A-d>  :call RopeGotoDefinition()<CR>
nnoremap <A-r> :call RopeRename()<CR>

" NERD commander Key bindings
nnoremap <C-q> \ci

" Allows for global mappings
"let g:ragtag_global_maps=1

" }

" Search {
" Toggles highlighting search results in buffer
noremap <F4> :set hlsearch! hlsearch?<CR>

" Jumping lands on top or bottom of screen
verbose nnoremap n nzz
verbose nnoremap } }zz

" }

" Status Line {
"set statusline=%9*\ %y\ (\%l\/\%L\):%v\ (%P)\ %F\ %m%=%{fugitive#statusline()}\    
set statusline=%9* " File type
set statusline+=\ %y " File type
set statusline+=\ (%P) " Percent of file
set statusline+=\ %c "Current Column
set statusline+=\:(\%l\/\%L) " Current line number / Total Lines
" set statusline+=\ %{FileSize()}
set statusline+=\ %F " Full file path
set statusline+=\ %m%=%{fugitive#statusline()} " Is file modified

" always show the status line
set laststatus=2

" Show some context while scrolling
set scrolloff=5
" }

" Syntax {
hi Comment ctermfg=green

" }

" Tabs {
set showtabline=2

verbose imap <C-,>t <Esc>:tabnew<CR>

verbose map <A-left>   :tabp<cr>
verbose noremap <A-S-h>  :tabp<cr>
verbose map <A-right>  :tabn<cr>
verbose noremap <A-S-l>  :tabn<cr>

map <A-]> :tab split<CR>:exec("tag ".expand("<cword>"))<CR>
map <C-}> :vsp <CR>:exec("tag ".expand("<cword>"))<CR>
" }


" UI {
set mouse=a
" highlight the current column
"set cursorcolumn 

" highlight current line BUT do highlight as you type you search phrase
"set cursorline 
set incsearch 
"
" end of line column
"set columns=150

" Highlights anything over 80 chars
highlight OverLength ctermbg=red ctermfg=white guibg=#592929
" match OverLength /\>%80v.\+/

" }

" Vundle {
" NOTE Start and end with setting filetype
filetype off
set rtp+=~/.vim/bundle/vundle/
silent! call vundle#rc()

" My Bundles
" First let Vundle handle itself
silent! Bundle 'gmarik/vundle'

" You Complete Me (ycm)
silent! Bundle 'Valloric/YouCompleteMe'

" Vim Ruby Support
silent! Bundle 'vim-ruby/vim-ruby'

" Vim Ruby on Rails Support
silent! Bundle 'vim-rails/vim-rails'

filetype plugin indent on
" }


" Functions {
function! FileSize()
        let bytes = getfsize(expand("%:p"))
        if bytes <= 0
                return ""
        endif
        if bytes < 1024
                return bytes
                return (bytes / 1024) . "K"
        endif
endfunction

function ClosePair(char)
	if getline('.')[col('.') - 1] == a:char
		return "\<Right>"
	else
		return a:char
	endif
endfunction

function QuoteDelim(char)
	let line = getline('.')
	let col = col('.')
	if line[col - 2] == "\\"
		" Inserting an escaped (and therefore conditionally asymmetric) quotation mark into the string
		return a:char
	elseif line[col-1] == a:char
		" Escaping out of the string
		return "\<Right>"
	else
		"Starting a string
		return a:char.a:char."\<Esc>i"
	endif
endfunction

" Append modeline after last line in buffer.
" Use substitute() instead of printf() to handle '%%s' modeline in LaTeX
" files.
function! AppendModeline()
  let l:modeline = printf(" vim: set ts=%d sw=%d tw=%d %set :",
        \ &tabstop, &shiftwidth, &textwidth, &expandtab ? '' : 'no')
  let l:modeline = substitute(&commentstring, "%s", l:modeline, "")
  call append(line("$"), l:modeline)
endfunction
nnoremap <silent> <Leader>ml :call AppendModeline()<CR>

" }
