""
" Name: .vimrc.funcs
" Description: Functions used by Vim. NOTE The `!` Means
"               override function on sourcing (prevents error messages).
""
function! DeleteHiddenBuffers()
    let tpbl=[]
    call map(range(1, tabpagenr('$')), 'extend(tpbl, tabpagebuflist(v:val))')
    for buf in filter(range(1, bufnr('$')), 'bufexists(v:val) && index(tpbl, v:val)==-1')
        silent execute 'bwipeout' buf
    endfor
endfunction

""
" Name: ReloadTabs
" Command: `Tb` - Executes ReloadTabs()
" Description: Reloads all the windows and tabs. Runs auto resize
" to reset size (using `CTRL-W =`)
""
function! ReloadTabs()
    " Reload all tabs and windows. Then reset window size
    execute "tabdo windo e"
    execute "tabdo normal! ="
endfunction
command! Tb call ReloadTabs()

function! FocusLostInsertMode()
    if v:insertmode
        feedkeys("\<C-\>\<C-n>")
    endif
endfunction

function! SimpleFoldText()
    return getline(v:foldstart).' '
endfunction

function! <SID>StripTrailingWhitespaces()
    let l = line(".")
    let c = col(".")
    %s/\s\+$//e
    call cursor(l, c)
endfun
autocmd FileType c,cpp,css,scss,html,javascript,java,php,ruby,python autocmd BufWritePre <buffer> :call <SID>StripTrailingWhitespaces()

function! QuoteDelim(char)
	let line = getline('.')
	let col = col('.')
	if line[col - 2] == "\\"
		" Inserting an escaped (and therefore conditionally asymmetric)
        " quotation mark into the string
		return a:char
	elseif line[col-1] == a:char
		" Escaping out of the string
		return "\<Right>"
	else
		"Starting a string
		return a:char.a:char."\<Esc>i"
	endif
endfunction

" Append modeline after last line in buffer.
" Use substitute() instead of printf() to handle '%%s' modeline in LaTeX
" files.
function! AppendModeline()
  let l:modeline = printf(" vim: set ts=%d sw=%d tw=%d %set :",
        \ &tabstop, &shiftwidth, &textwidth, &expandtab ? '' : 'no')
  let l:modeline = substitute(&commentstring, "%s", l:modeline, "")
  call append(line("$"), l:modeline)
endfunction
nnoremap <silent> <Leader>ml :call AppendModeline()<CR>

" Sends any ex to a scratch buffer
function! s:Scratch(command, ...)
   redir => lines
   let saveMore = &more
   set nomore
   execute a:command
   redir END
   let &more = saveMore
   call feedkeys("\<cr>")

   " Create the new buffer here
   tabe | setlocal buftype=nofile bufhidden=hide noswapfile
   put=lines
   if a:0 > 0
      execute 'vglobal/'.a:1.'/delete'
   endif
   if a:command == 'scriptnames'
      %substitute#^[[:space:]]*[[:digit:]]\+:[[:space:]]*##e
   endif
   silent %substitute/\%^\_s*\n\|\_s*\%$
   let height = line('$') + 3
   execute 'normal! z'.height."\<cr>"

   " Return
   0
endfunction

command! -nargs=? Scrtnames call <sid>Scratch('scriptnames', <f-args>)
command! -nargs=? Syntax call <sid>Scratch('syntax', <f-args>)
command! -nargs=+ Scratch call <sid>Scratch(<f-args>)


" Execute 'cmd' while redirecting output.
" Delete all lines that do not match regex 'filter' (if not empty).
" Delete any blank lines.
" Delete '<whitespace><number>:<whitespace>' from start of each line.
" Display result in a scratch buffer.
function! s:Filter_lines(cmd, filter)
    let save_more = &more
    set nomore
    redir => lines
    silent execute a:cmd
    redir END
    let &more = save_more
    new
    setlocal buftype=nofile bufhidden=hide noswapfile
    put =lines
    g/^\s*$/d
    %s/^\s*\d\+:\s*//e
    if !empty(a:filter)
        execute 'v/' . a:filter . '/d'
    endif
    0
endfunction
command! -nargs=? Scriptnames call s:Filter_lines('scriptnames', <q-args>)


" Called with a command and a redirection target
"   (see `:help redir` for info on redirection targets)
" Note that since this is executed in function context,
"   in order to target a global variable for redirection you must prefix it with `g:`.
" EG call Redir('ls', '=>g:buffer_list')
function! Redir(command, to)
  exec 'redir '.a:to
  exec a:command
  redir END
endfunction

" The last non-space substring is passed as the redirection target.
" EG
"   :R ls @">
"   " stores the buffer list in the 'unnamed buffer'
" Redirections to variables or files will work,
"   but there must not be a space between the redirection operator and the variable name.
" Also note that in order to redirect to a global variable you have to preface it with `g:`.
"   EG
"     :R ls =>g:buffer_list
"     :R ls >buffer_list.txt
command! -nargs=+ R call call(function('Redir'), split(<q-args>, '\s\(\S\+\s*$\)\@='))
